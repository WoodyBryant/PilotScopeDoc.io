<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>4. Core Components (ML Side) &mdash; PilotScope 1.0 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="5. Example" href="example.html" />
    <link rel="prev" title="3. System Pipeline" href="system_pipeline.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            PilotScope
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="overview.html">1. Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="install.html">2. Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="system_pipeline.html">3. System Pipeline</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">4. Core Components (ML Side)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#components-of-pilotscope-for-data-exchange-and-control-over-database">4.1. Components of PilotScope for Data Exchange and Control over Database</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pilotconfig">4.2. PilotConfig</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pilotdatainteractor">4.3. PilotDataInteractor</a></li>
<li class="toctree-l2"><a class="reference internal" href="#dbcontroller">4.4. DBController</a></li>
<li class="toctree-l2"><a class="reference internal" href="#datamanager">4.5. DataManager</a></li>
<li class="toctree-l2"><a class="reference internal" href="#components-of-pilotscope-for-deployment-of-custom-algorithms">4.6. Components of PilotScope for Deployment of Custom Algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pilotmodel">4.7. PilotModel</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pushhandler-driver-applying-custom-algorithms-to-incoming-sql-queries-automatically">4.8. PushHandler (Driver): Applying custom algorithms to incoming SQL queries automatically</a></li>
<li class="toctree-l2"><a class="reference internal" href="#pilotscheduler">4.9. PilotScheduler</a></li>
<li class="toctree-l2"><a class="reference internal" href="#event">4.10. Event</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#pretrainingmodelevent">4.10.1. PretrainingModelEvent</a></li>
<li class="toctree-l3"><a class="reference internal" href="#periodicmodelupdateevent">4.10.2. PeriodicModelUpdateEvent</a></li>
<li class="toctree-l3"><a class="reference internal" href="#registering-events-into-pilotscheduler">4.10.3. Registering Events into PilotScheduler</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dataset">4.11. Dataset</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="example.html">5. Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">6. API (ML Side)</a></li>
<li class="toctree-l1"><a class="reference internal" href="database_develop.html">7. Database Side Develop</a></li>
<li class="toctree-l1"><a class="reference internal" href="annotations.html">8. Annotations</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">PilotScope</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active"><span class="section-number">4. </span>Core Components (ML Side)</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/references/core_modules.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="core-components-ml-side">
<span id="section-core-components"></span><h1><span class="section-number">4. </span>Core Components (ML Side)<a class="headerlink" href="#core-components-ml-side" title="Permalink to this headline"></a></h1>
<p>The components of PilotScope Core in ML side can be divided into two categories: Database Components and Deployment
Components.
The Database Components are used to facilitate data exchange and control over database, while the Deployment Components
are used to facilitate the automatic application of custom AI algorithms to each incoming SQL query.</p>
<p>A high-level overview of the PilotScope Core components is shown in the following figure.</p>
<div align="center"  >
  <img src="../_static/pilotscope_module_framework.png" alt="PilotScope" style="width: 80%;" />
</div>
<p>The Database Components are highlighted in Yellow, while the Deployment Components are highlighted in green. We will
discuss each of these components in detail in the following sections.</p>
<section id="components-of-pilotscope-for-data-exchange-and-control-over-database">
<h2><span class="section-number">4.1. </span>Components of PilotScope for Data Exchange and Control over Database<a class="headerlink" href="#components-of-pilotscope-for-data-exchange-and-control-over-database" title="Permalink to this headline"></a></h2>
<p>To facilitate data exchange and control over database, PilotScope incorporates the following components:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">PilotConfig</span></code>: It is utilized to configure the PilotScope application. It includes various configurations such as the
database credentials for establishing a connection, the runtime settings such as timeout duration, and more.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PilotDataInteractor</span></code>: This component provides a flexible workflow for data exchange. It includes three main
functions: push, pull, and execute. These functions assist the user in collecting data (pull operators) after setting
additional data (push operators) in a single query execution process.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DBController</span></code>: It provides a powerful and unified ability to control various databases. It supports various
functionalities such as setting knobs, creating indexes, restarting databases, and more.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">DataManager</span></code>: It provides several high-level functions to conveniently store and read data.</p></li>
</ul>
</section>
<section id="pilotconfig">
<h2><span class="section-number">4.2. </span>PilotConfig<a class="headerlink" href="#pilotconfig" title="Permalink to this headline"></a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">PilotConfig</span></code> class is utilized to configure the PilotScope application.
It includes various configurations such as the database credentials for establishing a connection, the runtime settings
such as timeout duration, and more.</p>
<p>To quickly connect PilotScope to a PostgreSQL database named <code class="docutils literal notranslate"><span class="pre">stats_tiny</span></code>, the user can use the following code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example of PilotConfig</span>
<span class="n">config</span><span class="p">:</span> <span class="n">PilotConfig</span> <span class="o">=</span> <span class="n">PostgreSQLConfig</span><span class="p">(</span><span class="n">host</span><span class="o">=</span><span class="s2">&quot;localhost&quot;</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="s2">&quot;5432&quot;</span><span class="p">,</span> <span class="n">user</span><span class="o">=</span><span class="s2">&quot;postgres&quot;</span><span class="p">,</span> <span class="n">pwd</span><span class="o">=</span><span class="s2">&quot;postgres&quot;</span><span class="p">)</span>
<span class="c1"># You can also instantiate a PilotConfig for other DBMSes. e.g. </span>
<span class="c1"># config:PilotConfig = SparkConfig()</span>
<span class="n">config</span><span class="o">.</span><span class="n">db</span> <span class="o">=</span> <span class="s2">&quot;stats_tiny&quot;</span>
<span class="c1"># Configure PilotScope here, e.g. changing the name of database you want to connect to.</span>
</pre></div>
</div>
<p><strong>You can quickly load the test dataset (e.g., <code class="docutils literal notranslate"><span class="pre">stats_tiny</span></code> or <code class="docutils literal notranslate"><span class="pre">imdb_tiny</span></code> databases) into PostgreSQL by referring to the <a class="reference external" href="#dataset">Dataset</a> section.</strong></p>
<p>In the above code, the <code class="docutils literal notranslate"><span class="pre">stats_tiny</span></code> database is accessed using the username <code class="docutils literal notranslate"><span class="pre">postgres</span></code> and the password <code class="docutils literal notranslate"><span class="pre">postgres</span></code>.
The database is located on the <code class="docutils literal notranslate"><span class="pre">localhost</span></code> machine with port number <code class="docutils literal notranslate"><span class="pre">5432</span></code>.</p>
<p>In certain scenarios, when the user needs to perform more complex functionalities like restarting the database (usually
in Knob tuning tasks),
additional configurations related to the installation information of the database are required.</p>
<p>To enable deep control functionality, the user can utilize the <code class="docutils literal notranslate"><span class="pre">enable_deep_control_local</span></code>
or <code class="docutils literal notranslate"><span class="pre">enable_deep_control_remote</span></code> method in the PilotConfig class.
Those 2 methods take in several parameters related to the database installation information. If the PostgreSQL database
and the ML side program are running on the same machine,
please use <code class="docutils literal notranslate"><span class="pre">enable_deep_control_local</span></code>. Otherwise, use <code class="docutils literal notranslate"><span class="pre">enable_deep_control_remote</span></code>. Here is an example code snippet:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># pg_bin_path: The directory of binary file of postgresql, i.e. the path of &#39;postgres&#39;, &#39;pg_ctl&#39; etc.</span>
<span class="c1"># pg_data_path: The path to the PostgreSQL data directory (pgdata) where the database files are stored.</span>
<span class="n">config</span><span class="o">.</span><span class="n">enable_deep_control_local</span><span class="p">(</span><span class="n">pg_bin_path</span><span class="p">,</span> <span class="n">pg_data_path</span><span class="p">)</span>
</pre></div>
</div>
<p>For remote control, you will need to connect to the remote machine via SSH for control.
In addition to the parameters mentioned above, you will also need the username, password, and SSH port of the remote
machine.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># db_host_user: The username to log in to the machine with database.</span>
<span class="c1"># db_host_pwd: The corresponding password</span>
<span class="c1"># db_host_ssh_port:  SSH port of the remote machine.</span>
<span class="n">config</span><span class="o">.</span><span class="n">enable_deep_control_remote</span><span class="p">(</span><span class="n">pg_bin_path</span><span class="p">,</span> <span class="n">pg_data_path</span><span class="p">,</span> <span class="n">db_host_user</span><span class="p">,</span> <span class="n">db_host_pwd</span><span class="p">,</span> <span class="n">db_host_ssh_port</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="pilotdatainteractor">
<h2><span class="section-number">4.3. </span>PilotDataInteractor<a class="headerlink" href="#pilotdatainteractor" title="Permalink to this headline"></a></h2>
<p>The PilotDataInteractor class provides a flexible workflow for data exchange. It includes three main functions: push,
pull, and execute.
These functions assist the user in collecting data (pull operators) after setting additional data (push operators) in a
single query execution process.</p>
<p>Specifically, the <code class="docutils literal notranslate"><span class="pre">pull</span></code> and <code class="docutils literal notranslate"><span class="pre">push</span></code> functions are used to register information related to data collection and settings.
It is important to note that they are used to register information, and do not trigger the execution of a query.</p>
<p>To execute a SQL query, the user needs to call the <code class="docutils literal notranslate"><span class="pre">execute</span></code> function.
This function triggers the actual execution of the query and retrieves the desired information.</p>
<p>For instance, if the user wants to collect the execution time, estimated cost, and cardinality of all sub-queries within
a query. Here is an example code:
Refer to chapter <a class="reference external" href="../references/api_rst/pilotscope.DBInteractor.PilotDataInteractor.html#pilotscope.DBInteractor.PilotDataInteractor.PilotDataInteractor">6. API (ML Side) pilotscope.DataFetcher.PilotDataInteractor</a> for more details.</p>
<!--
In implementation, each operator corresponds to an *anchor*, and each function call below registers a corresponding *anchor* in this instance.
-->
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">sql</span> <span class="o">=</span> <span class="s2">&quot;select count(*) from votes as v, badges as b, users as u where u.id = v.userid and v.userid = b.userid and u.downvotes&gt;=0 and u.downvotes&lt;=0&quot;</span>
<span class="n">data_interactor</span> <span class="o">=</span> <span class="n">PilotDataInteractor</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
<span class="n">data_interactor</span><span class="o">.</span><span class="n">pull_estimated_cost</span><span class="p">()</span>
<span class="n">data_interactor</span><span class="o">.</span><span class="n">pull_subquery_card</span><span class="p">()</span>
<span class="n">data_interactor</span><span class="o">.</span><span class="n">pull_execution_time</span><span class="p">()</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">data_interactor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">sql</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">execute</span></code> function returns a <code class="docutils literal notranslate"><span class="pre">PilotTransData</span></code> object named <code class="docutils literal notranslate"><span class="pre">data</span></code>, which serves as a placeholder for the collected
data.
Each member of this object represents a specific data point, and the values corresponding to the previously
registered <code class="docutils literal notranslate"><span class="pre">pull</span></code> operators will be filled in, while the other values will remain as None.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">execution_time</span><span class="p">:</span> <span class="mf">0.00173</span>
<span class="n">estimated_cost</span><span class="p">:</span> <span class="mf">98.27</span>
<span class="n">subquery_2_card</span><span class="p">:</span> <span class="p">{</span><span class="s1">&#39;select count(*) from votes v&#39;</span><span class="p">:</span> <span class="mf">3280.0</span><span class="p">,</span> <span class="s1">&#39;select count(*) from badges b&#39;</span><span class="p">:</span> <span class="mf">798.0</span><span class="p">,</span> <span class="s1">&#39;select count(*) from users u where u.downvotes &gt;= 0 and u.downvotes &lt;= 0&#39;</span><span class="p">:</span> <span class="mf">399.000006</span><span class="p">,</span> <span class="s1">&#39;select count(*) from votes v, badges b where v.userid = b.userid;&#39;</span><span class="p">:</span> <span class="mf">368.609177</span><span class="p">,</span> <span class="s1">&#39;select count(*) from votes v, users u where v.userid = u.id and u.downvotes &gt;= 0 and u.downvotes &lt;= 0;&#39;</span><span class="p">:</span> <span class="mf">333.655156</span><span class="p">,</span> <span class="s1">&#39;select count(*) from badges b, users u where b.userid = u.id and u.downvotes &gt;= 0 and u.downvotes &lt;= 0;&#39;</span><span class="p">:</span> <span class="mf">425.102804</span><span class="p">,</span> <span class="s1">&#39;select count(*) from votes v, badges b, users u where v.userid = u.id and v.userid = b.userid and u.downvotes &gt;= 0 and u.downvotes &lt;= 0;&#39;</span><span class="p">:</span> <span class="mf">37.536205</span><span class="p">}</span>
<span class="n">buffercache</span><span class="p">:</span> <span class="kc">None</span>
<span class="o">...</span>
</pre></div>
</div>
<p>In certain scenarios, when the user wants to collect the execution time of a SQL query after applying a new
cardinality (e.g., scaling the original cardinality by 100) for all sub-queries within the SQL,
the PilotDataInteractor provides push function to achieve this.
Here is an example code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example of PilotDataInteractor (registering operators again and execution)</span>
<span class="n">data_interactor</span><span class="o">.</span><span class="n">push_card</span><span class="p">({</span><span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="o">*</span> <span class="mi">100</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">subquery_2_card</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
<span class="n">data_interactor</span><span class="o">.</span><span class="n">pull_estimated_cost</span><span class="p">()</span>
<span class="n">data_interactor</span><span class="o">.</span><span class="n">pull_execution_time</span><span class="p">()</span>
<span class="n">new_data</span> <span class="o">=</span> <span class="n">data_interactor</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">sql</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">new_data</span><span class="p">)</span>
</pre></div>
</div>
<p>By default, each call to the execute function will reset any previously registered operators.
Therefore, we need to push these new cardinalities and re-register the pull operators to collect the estimated cost and
execution time.
In this scenario, the new cardinalities will replace the ones estimated by the database’s cardinality estimator.
As a result, the partial result of the <code class="docutils literal notranslate"><span class="pre">new_data</span></code> object will be significantly different from the result of the <code class="docutils literal notranslate"><span class="pre">data</span></code>
object,
mainly due to the variation in cardinality values.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">execution_time</span><span class="p">:</span> <span class="mf">0.00208</span>
<span class="n">estimated_cost</span><span class="p">:</span> <span class="mf">37709.05</span>
<span class="o">...</span>
</pre></div>
</div>
<p>More details about <code class="docutils literal notranslate"><span class="pre">PilotDataInteractor</span></code> and all operators see
chapter <a class="reference external" href="../references/api_rst/pilotscope.DBInteractor.PilotDataInteractor.html#pilotscope.DBInteractor.PilotDataInteractor.PilotDataInteractor">6. API (ML Side) pilotscope.DataFetcher.PilotDataInteractor</a>
.</p>
</section>
<section id="dbcontroller">
<h2><span class="section-number">4.4. </span>DBController<a class="headerlink" href="#dbcontroller" title="Permalink to this headline"></a></h2>
<p>The DBController class provides a powerful and unified ability to control various databases.
It supports various functionalities such as setting knobs, creating indexes, restarting databases, and more.
Here is an example code that demonstrates how to use it:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example of DBController</span>
<span class="n">db_controller</span><span class="p">:</span> <span class="n">BaseDBController</span> <span class="o">=</span> <span class="n">DBControllerFactory</span><span class="o">.</span><span class="n">get_db_controller</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">)</span>

<span class="c1"># Restarting the database</span>
<span class="n">db_controller</span><span class="o">.</span><span class="n">restart</span><span class="p">()</span>
</pre></div>
</div>
<p>In this example, we first create an instance of the DBController class by calling DBControllerFactory.get_db_controller
and passing in the necessary configuration.
This will return an object that implements the BaseDBController interface. Such as PostgreSQLDBController,
SparkDBController, etc.
Next, we can use the db_controller object to perform various operations on the database.
In this case, we call the restart method to restart the database.</p>
<p>When instantiating using a factory, the default value for  <code class="docutils literal notranslate"><span class="pre">enable_simulate_index</span></code> is False. However,
setting <code class="docutils literal notranslate"><span class="pre">enable_simulate_index</span></code> to True will transform all index operations into operations on hypothetical indexes.
Please note that in order to use hypothetical indexes, the connected database must have
the <code class="docutils literal notranslate"><span class="pre">HypoPG</span> <span class="pre">&lt;https://github.com/HypoPG/hypopg&gt;</span></code>_ extension installed.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">db_controller</span><span class="p">:</span> <span class="n">PostgreSQLController</span> <span class="o">=</span> <span class="n">DBCntrollerFactory</span><span class="o">.</span><span class="n">get_db_controller</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="n">enable_simulate_index</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">res</span> <span class="o">=</span> <span class="n">db_controller</span><span class="o">.</span><span class="n">get_all_indexes</span><span class="p">()</span>
<span class="n">index</span> <span class="o">=</span> <span class="n">Index</span><span class="p">([</span><span class="s2">&quot;date&quot;</span><span class="p">],</span> <span class="s2">&quot;badges&quot;</span><span class="p">,</span> <span class="n">index_name</span><span class="o">=</span><span class="s2">&quot;index_name&quot;</span><span class="p">)</span>
<span class="n">db_controller</span><span class="o">.</span><span class="n">create_index</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">db_controller</span><span class="o">.</span><span class="n">get_all_indexes</span><span class="p">())</span>
</pre></div>
</div>
<p>The Hypothetical indexes created with HypoPG are effective only within a single connection. Once the connection is
reset, all hypothetical indexes will be lost. Also, since the hypothetical indexes doesn’t really exists, HypoPG makes
sure they will only be used using a simple EXPLAIN statement without the ANALYZE option in PostgreSQL terminal (
so <code class="docutils literal notranslate"><span class="pre">explain_physical_plan</span></code> and <code class="docutils literal notranslate"><span class="pre">get_estimated_cost</span></code> can work). In our implementations, if hypothetical indexes are
enabled, all real indexes are hidden.</p>
<p>For more functionalities and methods provided by the DBController class, you can refer to
the <a class="reference external" href="../references/api_rst/pilotscope.DBController.BaseDBController.html#module-pilotscope.DBController.BaseDBController">6. API (ML Side) pilotscope.DBController.BaseDBController</a>
.</p>
<p>It’s important to distinguish that <code class="docutils literal notranslate"><span class="pre">PilotDataInteractor</span></code> is designed to collect data when executing SQL queries, while
the <code class="docutils literal notranslate"><span class="pre">DBController</span></code> class is specifically focused on providing control over the database itself.
<code class="docutils literal notranslate"><span class="pre">PilotDataInteractor</span></code> is also implemented based on the functionality provided by <code class="docutils literal notranslate"><span class="pre">DBController</span></code>.</p>
</section>
<section id="datamanager">
<h2><span class="section-number">4.5. </span>DataManager<a class="headerlink" href="#datamanager" title="Permalink to this headline"></a></h2>
<p>DataManager class provide several high-level functions to conveniently store and read data.
These created tables are saved in a database named <code class="docutils literal notranslate"><span class="pre">PilotScopeUserData</span></code>.
Here is an example code that show how to use it:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">data_manager</span> <span class="o">=</span> <span class="n">DataManager</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="p">)</span>
<span class="n">table_name</span> <span class="o">=</span> <span class="s2">&quot;test_table&quot;</span>

<span class="n">row_data</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;test&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span>
<span class="c1"># write data into table </span>
<span class="n">data_manager</span><span class="o">.</span><span class="n">save_data</span><span class="p">(</span><span class="n">row_data</span><span class="p">)</span>

<span class="c1"># read all data from the table</span>
<span class="n">result</span><span class="p">:</span> <span class="n">DataFrame</span> <span class="o">=</span> <span class="n">data_manager</span><span class="o">.</span><span class="n">read_all</span><span class="p">()</span>

<span class="c1"># read all data from the position where the last read (by read_update or read all function) ends </span>
<span class="n">result</span><span class="p">:</span> <span class="n">DataFrame</span> <span class="o">=</span> <span class="n">data_manager</span><span class="o">.</span><span class="n">read_update</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</pre></div>
</div>
<p>More details about <code class="docutils literal notranslate"><span class="pre">DataManager</span></code> see  <a class="reference external" href="../references/api_rst/pilotscope.DataManager.DataManager.html#module-pilotscope.DataManager.DataManager">6. API (ML Side) pilotscope.DataManager.DataManager</a> .</p>
</section>
<section id="components-of-pilotscope-for-deployment-of-custom-algorithms">
<h2><span class="section-number">4.6. </span>Components of PilotScope for Deployment of Custom Algorithms<a class="headerlink" href="#components-of-pilotscope-for-deployment-of-custom-algorithms" title="Permalink to this headline"></a></h2>
<p>To facilitate the automatic application of custom algorithms to each incoming SQL query, PilotScope incorporates the
following components:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">PilotModel</span></code>: This component assists users in managing the storage and loading of models at the appropriate time and
place automatically. It streamlines the process of utilizing custom algorithms within the PilotScope system.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PushHandler</span></code>: The PushHandler component plays a crucial role in applying values generated by the custom algorithm to
the database during the execution of a SQL query. It enables seamless integration between the custom algorithm and the
database operations.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PilotScheduler</span></code>: Serving as the central controller and entry point of the PilotScope system pipeline, the component
orchestrates the various stages and components involved in the deployment of custom algorithms. It handles the
management and coordination of tasks throughout the system.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">PilotEvent</span></code>: It is employed to implement custom functionalities at different execution stages, such as the conclusion
of a SQL query execution. PilotScope also provides pre-defined events that users can directly utilize, including
the <code class="docutils literal notranslate"><span class="pre">PeriodicModelUpdateEvent</span></code>, which enables periodic updates of the model.</p></li>
</ul>
<p>In the subsequent sections, we will provide a detailed introduction to each of these components, outlining their
functionalities and capabilities.</p>
</section>
<section id="pilotmodel">
<h2><span class="section-number">4.7. </span>PilotModel<a class="headerlink" href="#pilotmodel" title="Permalink to this headline"></a></h2>
<p>The Users can leverage PilotScope to manage the storage and loading of models by inheriting from the PilotModel class.
Here’s an example of how to utilize it:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Example of PilotModel</span>
<span class="n">pilot_model</span><span class="p">:</span> <span class="n">PilotModel</span> <span class="o">=</span> <span class="n">ExamplePilotModel</span><span class="p">(</span><span class="n">model_name</span><span class="p">)</span>
<span class="n">pilot_model</span><span class="o">.</span><span class="n">load_model</span><span class="p">()</span>
</pre></div>
</div>
<p>In the provided example, the user creates an instance of a subclass of <code class="docutils literal notranslate"><span class="pre">PilotModel</span></code> called <code class="docutils literal notranslate"><span class="pre">ExamplePilotModel</span></code>.
The <code class="docutils literal notranslate"><span class="pre">model_name</span></code> parameter represents the name of the model being used.
Following that, the <code class="docutils literal notranslate"><span class="pre">load</span></code> method is invoked to load the model.
In order to use PilotModel, subclasses need to implement two important abstract methods: <code class="docutils literal notranslate"><span class="pre">_save_model</span></code>
and <code class="docutils literal notranslate"><span class="pre">_load_model</span></code>. These methods define how the model should be saved and loaded, respectively.</p>
<p>The Subclasses of <code class="docutils literal notranslate"><span class="pre">PilotModel</span></code> should implement two important abstract methods, <code class="docutils literal notranslate"><span class="pre">_save_model</span></code> and <code class="docutils literal notranslate"><span class="pre">_load_model</span></code>,
respectively.
This ensures a unified interface for model management and allows for the seamless integration of custom models into the
PilotScope framework.</p>
</section>
<section id="pushhandler-driver-applying-custom-algorithms-to-incoming-sql-queries-automatically">
<h2><span class="section-number">4.8. </span>PushHandler (Driver): Applying custom algorithms to incoming SQL queries automatically<a class="headerlink" href="#pushhandler-driver-applying-custom-algorithms-to-incoming-sql-queries-automatically" title="Permalink to this headline"></a></h2>
<div align="center"  >
  <img src="../_static/push_handler.png" alt="PilotScope" style="width: 80%;" />
</div>
<p>The PushHandler component within PilotScope plays a crucial role in applying the values generated by custom algorithms
to the database during the execution of a SQL query. PilotScope supports various types of data that can be injected into
the query, including hints, cardinalities, and more.</p>
<p>To specify the type of data to be replaced, users can inherit from different subclasses of PushHandler, such as
HintPushHandler and CardPushHandler. These subclasses are designed specifically for replacing hints and cardinalities,
respectively.
Each subclass of PushHandler should implement the <code class="docutils literal notranslate"><span class="pre">acquire_injected_data</span></code> method.
This method is responsible for generating and returning the value that will be injected into the database during query
execution.
The specific implementation of this method will differ depending on the custom algorithms.</p>
<!---
For tasks like cardinality estimation and some learned query optimizers, the whole process of them is like a single *push anchor*, whose datas come from their algorithms rather than being manually specified as shown above. Therefore, the entire process can be completed by inheriting the original *anchor* and implementing their respective `user_custom_task` methods. For example, a cardinality estimation task should inherit `CardAnchorHandler` and implement the cardinality estimation function in `user_custom_task`, that is, use `pull_subquery_card()` to obtain subqueries, and then use its own algorithm to make an estimate on these subqueries, and return the cardinality corresponding to each subquery.
-->
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CustomCardPushHandler</span><span class="p">(</span><span class="n">CardPushHandler</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">acquire_injected_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sql</span><span class="p">):</span>
        <span class="c1"># using your own algorithm to get cardinality.</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_algorithm</span><span class="p">(</span><span class="n">sql</span><span class="p">)</span>

        <span class="c1"># data is a dict, key is subquery, value is cardinality.</span>
        <span class="k">return</span> <span class="n">data</span>
</pre></div>
</div>
<p>Additionally, we have implemented <code class="docutils literal notranslate"><span class="pre">KnobPushHandler</span></code>, <code class="docutils literal notranslate"><span class="pre">HintPushHandler</span></code>, <code class="docutils literal notranslate"><span class="pre">IndexPushHandler</span></code>, and more, which can be used
to replace knobs, hints, and indexes, respectively.
These AnchorHandlers can be found in
chapter <a class="reference external" href="../references/api_rst/pilotscope.Anchor.BaseAnchor.BasePushHandler.html#module-pilotscope.Anchor.BaseAnchor.BasePushHandler">6. API (ML Side) pilotscope.Anchor.BaseAnchor.BasePushHandler</a>
.</p>
</section>
<section id="pilotscheduler">
<h2><span class="section-number">4.9. </span>PilotScheduler<a class="headerlink" href="#pilotscheduler" title="Permalink to this headline"></a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">PilotScheduler</span></code> acts as the central controller and entry point for the system pipeline.
It orchestrates the various stages and components involved in the deployment of custom algorithms, ensuring seamless
integration and execution.</p>
<p>This component enables users to register diverse configurations, including custom PushHandler objects, the data to be
collected, events, and more.
All incoming SQL queries are processed through the <code class="docutils literal notranslate"><span class="pre">PilotScheduler</span></code> class, which automatically injects the customized
algorithms, collects the required data, and periodically checks for trigger events.</p>
<p>In the following code, the <code class="docutils literal notranslate"><span class="pre">SchedulerFactory</span></code> is used to produce an instance of <code class="docutils literal notranslate"><span class="pre">PilotScheduler</span></code>, and
a <code class="docutils literal notranslate"><span class="pre">CustomCardPushHandler</span></code> object is registered with the PilotScheduler.
PilotScope supports registering multiple handlers with different types of injected data.
For each incoming SQL query, the PilotScheduler first calls the <code class="docutils literal notranslate"><span class="pre">acquire_injected_data</span></code> method of all registered
handlers to collect the corresponding values from the custom algorithms, and then injects these data into database.
You can see some examples in chapter <a class="reference internal" href="example.html#section-example"><span class="std std-ref">Example</span></a></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># the custom algorithm is implemented in CustomCardPushHandler</span>
<span class="n">customCardPushHandler</span> <span class="o">=</span> <span class="n">CustomCardPushHandler</span><span class="p">()</span>
<span class="c1"># Example of PilotScheduler</span>
<span class="n">scheduler</span> <span class="o">=</span> <span class="n">SchedulerFactory</span><span class="o">.</span><span class="n">create_scheduler</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
<span class="n">scheduler</span><span class="o">.</span><span class="n">register_custom_handlers</span><span class="p">([</span><span class="n">customCardPushHandler</span><span class="p">])</span>
<span class="n">scheduler</span><span class="o">.</span><span class="n">execute</span><span class="p">(</span><span class="n">sql</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">execute</span></code> method of the <code class="docutils literal notranslate"><span class="pre">PilotScheduler</span></code> is responsible for receiving an input SQL query and injecting the values
from the custom algorithms into the database during the execution of the query.</p>
<p>In order to update and evaluate the model periodically, it is often necessary to collect data during the execution of
SQL
queries. PilotScope simplifies this process by providing a <code class="docutils literal notranslate"><span class="pre">register_required_data</span></code> function to automatically collect
and store data into a
table.
Here is an example code that show how to collect data automatically:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># a example to collect partial data</span>
<span class="n">scheduler</span><span class="o">.</span><span class="n">register_required_data</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">test_data_table</span><span class="p">,</span> <span class="n">pull_physical_plan</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pull_execution_time</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above code, the <code class="docutils literal notranslate"><span class="pre">register_required_data</span></code> method is used to register the data that needs to be collected.
In this example, the physical plan and execution time are specified as the data to be collected by setting
the <code class="docutils literal notranslate"><span class="pre">pull_physical_plan</span></code> and <code class="docutils literal notranslate"><span class="pre">pull_execution_time</span></code> parameters to True.
When executing SQL queries, PilotScope automatically collects the specified data and stores them into a table
named <code class="docutils literal notranslate"><span class="pre">test_data_table</span></code>, and the user can read table data by calling the <code class="docutils literal notranslate"><span class="pre">DataManager</span></code> class.
All tables are stored in the database named <code class="docutils literal notranslate"><span class="pre">PilotScopeUserData</span></code>, which is specified in the <code class="docutils literal notranslate"><span class="pre">PilotSysConfig</span></code> class.</p>
<p>Please refer to the <a class="reference external" href="../references/api_rst/pilotscope.PilotScheduler.html#module-pilotscope.PilotScheduler">6. API (ML Side) pilotscope.PilotScheduler</a> for a detailed
description of the data that can be automatically collected using PilotScope.
More complicated requirements of data collection can be achieved by utilizing the <code class="docutils literal notranslate"><span class="pre">PilotEvent</span></code> component with
other components (e.g., <code class="docutils literal notranslate"><span class="pre">DBController</span></code>) provided by PilotScope.</p>
</section>
<section id="event">
<h2><span class="section-number">4.10. </span>Event<a class="headerlink" href="#event" title="Permalink to this headline"></a></h2>
<p>PilotScope provides multiple types of events that are triggered at different stages of execution.
For example, the <code class="docutils literal notranslate"><span class="pre">QueryFinishEvent</span></code> is triggered when a query is finished, and the <code class="docutils literal notranslate"><span class="pre">WorkloadBeforeEvent</span></code> is triggered
before a workload is started.</p>
<p>In addition, PilotScope offers two predefined events to facilitate model updating.
The first event is the <code class="docutils literal notranslate"><span class="pre">PeriodicModelUpdateEvent</span></code>, which can be used to periodically update the model.
The second event is the <code class="docutils literal notranslate"><span class="pre">PretrainingModelEvent</span></code>, which assists users in manually collecting data and pretraining the
model before PilotScope receives the input query.</p>
<section id="pretrainingmodelevent">
<h3><span class="section-number">4.10.1. </span>PretrainingModelEvent<a class="headerlink" href="#pretrainingmodelevent" title="Permalink to this headline"></a></h3>
<p>Let’s first discuss the <code class="docutils literal notranslate"><span class="pre">PretrainingModelEvent</span></code> in detail.</p>
<p>In general, before PilotScope receives the input query, the model should be trained using historical data.
To streamline this process, the <code class="docutils literal notranslate"><span class="pre">PretrainingModelEvent</span></code> abstracts two important functions: <code class="docutils literal notranslate"><span class="pre">iterative_data_collection</span></code>
and <code class="docutils literal notranslate"><span class="pre">custom_model_training</span></code>.
After inheriting from this class, users can implement these functions to customize the data collection and model
training process.</p>
<p>Here is an example code snippet that demonstrates how to use the <code class="docutils literal notranslate"><span class="pre">PretrainingModelEvent</span></code>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CustomPretrainingModelEvent</span><span class="p">(</span><span class="n">PretrainingModelEvent</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">:</span> <span class="n">PilotConfig</span><span class="p">,</span> <span class="n">bind_model</span><span class="p">:</span> <span class="n">PilotModel</span><span class="p">,</span> <span class="n">data_saving_table</span><span class="p">,</span> <span class="n">enable_collection</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">enable_training</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="n">bind_model</span><span class="p">,</span> <span class="n">data_saving_table</span><span class="p">,</span> <span class="n">enable_collection</span><span class="p">,</span> <span class="n">enable_training</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">iterative_data_collection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db_controller</span><span class="p">:</span> <span class="n">BaseDBController</span><span class="p">,</span> <span class="n">train_data_manager</span><span class="p">:</span> <span class="n">DataManager</span><span class="p">):</span>
        <span class="c1"># custom data collection, collected_data is a dict, key is name of a data , value is value of a data .</span>
        <span class="k">while</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_continue</span><span class="p">():</span>
            <span class="c1"># collecting 100 data each time</span>
            <span class="n">collected_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_collect_data</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">collected_data</span><span class="p">,</span> <span class="kc">False</span>
        <span class="n">collected_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">custom_collect_data</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">collected_data</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span>

    <span class="k">def</span> <span class="nf">custom_model_training</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bind_model</span><span class="p">,</span> <span class="n">db_controller</span><span class="p">:</span> <span class="n">BaseDBController</span><span class="p">,</span>
                              <span class="n">data_manager</span><span class="p">:</span> <span class="n">DataManager</span><span class="p">):</span>
        <span class="c1"># training model</span>
</pre></div>
</div>
<p>In the above code, the user inherit the <code class="docutils literal notranslate"><span class="pre">PretrainingModelEvent</span></code> and implements the <code class="docutils literal notranslate"><span class="pre">iterative_data_collection</span></code> function
to customize the process of data
collection.
This function returns two values: the first is the data collected in the current iteration, and the second is a
termination flag that indicates whether the data collection is finished.</p>
<p>PilotScope will repeatedly call the <code class="docutils literal notranslate"><span class="pre">iterative_data_collection</span></code> function. In each iteration, PilotScope automatically
stores the returned data into the table specified by <code class="docutils literal notranslate"><span class="pre">self.data_saving_table</span></code> and determines whether to stop the
iteration. If the termination flag is True, PilotScope stops the iteration and start to train the model by calling
the <code class="docutils literal notranslate"><span class="pre">custom_model_training</span></code> function.
Note that the created table <code class="docutils literal notranslate"><span class="pre">self.data_saving_table</span></code> is saved in a database named <code class="docutils literal notranslate"><span class="pre">PilotScopeUserData</span></code>.</p>
<p>The user can enable or disable data collection and model training by setting the <code class="docutils literal notranslate"><span class="pre">enable_collection</span></code>
and <code class="docutils literal notranslate"><span class="pre">enable_training</span></code>
parameters, respectively.</p>
</section>
<section id="periodicmodelupdateevent">
<h3><span class="section-number">4.10.2. </span>PeriodicModelUpdateEvent<a class="headerlink" href="#periodicmodelupdateevent" title="Permalink to this headline"></a></h3>
<p>The PeriodicModelUpdateEvent is used to periodically update the model,
and it provides the custom_model_update function that can be implemented to customize the model update process.</p>
<p>Here is an example code snippet that show how to use the PeriodicModelUpdateEvent:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">CustomPeriodicModelUpdateEvent</span><span class="p">(</span><span class="n">PeriodicModelUpdateEvent</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">config</span><span class="p">,</span> <span class="n">interval_count</span><span class="p">,</span> <span class="n">pilot_model</span><span class="p">:</span> <span class="n">PilotModel</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">execute_on_init</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="n">interval_count</span><span class="p">,</span> <span class="n">pilot_model</span><span class="p">,</span> <span class="n">execute_on_init</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">custom_model_update</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pilot_model</span><span class="p">:</span> <span class="n">PilotModel</span><span class="p">,</span> <span class="n">db_controller</span><span class="p">:</span> <span class="n">BaseDBController</span><span class="p">,</span>
                            <span class="n">data_manager</span><span class="p">:</span> <span class="n">DataManager</span><span class="p">):</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">data_manager</span><span class="o">.</span><span class="n">read_update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">custom_data_save_table</span><span class="p">)</span>
        <span class="c1"># update model using data</span>


<span class="n">event</span> <span class="o">=</span> <span class="n">CustomPeriodicModelUpdateEvent</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="n">interval_count</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">pilot_model</span><span class="o">=</span><span class="n">user_model</span><span class="p">,</span>
                                       <span class="n">execute_before_first_query</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<p>In the above code, the user inherits the <code class="docutils literal notranslate"><span class="pre">PeriodicModelUpdateEvent</span></code> class and implements the <code class="docutils literal notranslate"><span class="pre">custom_model_update</span></code>
function
to customize the process of model update. Within the <code class="docutils literal notranslate"><span class="pre">custom_model_update</span></code> function, the user can define the logic to
update the model using the collected data.</p>
<p>Next, the user instantiates the <code class="docutils literal notranslate"><span class="pre">CustomPeriodicModelUpdateEvent</span></code> class and specifies the frequency of model updates to
occur every 100 queries by setting the <code class="docutils literal notranslate"><span class="pre">interval_count</span></code> parameter to 100. Additionally, by setting the <code class="docutils literal notranslate"><span class="pre">execute_on_init</span></code>
parameter to True, the model update will be executed once when initializing the PilotScope.</p>
</section>
<section id="registering-events-into-pilotscheduler">
<h3><span class="section-number">4.10.3. </span>Registering Events into PilotScheduler<a class="headerlink" href="#registering-events-into-pilotscheduler" title="Permalink to this headline"></a></h3>
<p>The users can enable event triggering by registering them using the <code class="docutils literal notranslate"><span class="pre">register_events</span></code> method provided by PilotScheduler.
Here is an example code:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model_update_event</span> <span class="o">=</span> <span class="n">CustomPeriodicModelUpdateEvent</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="n">interval_count</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">pilot_model</span><span class="o">=</span><span class="n">user_model</span><span class="p">,</span>
                                                    <span class="n">execute_before_first_query</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">pretraining_event</span> <span class="o">=</span> <span class="n">CustomPretrainingModelEvent</span><span class="p">(</span><span class="n">config</span><span class="p">,</span> <span class="n">user_model</span><span class="p">,</span> <span class="n">pretraining_data_table</span><span class="p">,</span>
                                                <span class="n">enable_collection</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">enable_training</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">scheduler</span><span class="o">.</span><span class="n">register_events</span><span class="p">([</span><span class="n">model_update_event</span><span class="p">,</span> <span class="n">pretraining_event</span><span class="p">])</span>
</pre></div>
</div>
<p>Note that all extra created tables are saved in a database named <code class="docutils literal notranslate"><span class="pre">PilotScopeUserData</span></code>.</p>
</section>
</section>
<section id="dataset">
<h2><span class="section-number">4.11. </span>Dataset<a class="headerlink" href="#dataset" title="Permalink to this headline"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">pilotscope.Dataset</span></code> provide a easy method to load several popular datasets (e.g., IMDB and STATS) into PostgreSQL, and
also provide some common training and testing SQLs.
The following is an example of how to use it:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">pilotscope.Dataset.StatsTinyDataset</span> <span class="kn">import</span> <span class="n">StatsTinyDataset</span>
<span class="kn">from</span> <span class="nn">pilotscope.PilotEnum</span> <span class="kn">import</span> <span class="n">DatabaseEnum</span>

<span class="n">ds</span> <span class="o">=</span> <span class="n">StatsTinyDataset</span><span class="p">(</span><span class="n">DatabaseEnum</span><span class="o">.</span><span class="n">POSTGRESQL</span><span class="p">,</span> <span class="n">created_db_name</span><span class="o">=</span><span class="s2">&quot;stats_tiny&quot;</span><span class="p">,</span> <span class="n">data_dir</span><span class="o">=</span><span class="s2">&quot;./data&quot;</span><span class="p">)</span>
<span class="n">ds</span><span class="o">.</span><span class="n">load_to_db</span><span class="p">(</span><span class="n">config</span><span class="p">)</span>
<span class="c1"># config is a PilotConfig instance with configured enable_deep_control_local or enable_deep_control_remote</span>
</pre></div>
</div>
<p>In the above code, <code class="docutils literal notranslate"><span class="pre">StatsTinyDataset</span></code> is used to load a compressed STATS dataset into PostgreSQL.
The <code class="docutils literal notranslate"><span class="pre">load_to_db</span></code> method is used to download data from the internet by default to the <code class="docutils literal notranslate"><span class="pre">pilotscope_data</span></code> directory in the
user’s data directory. This directory may vary on different systems and can be checked using <code class="docutils literal notranslate"><span class="pre">appdirs.user_data_dir()</span></code>.
Alternatively, you can manually specify the data directory <code class="docutils literal notranslate"><span class="pre">data_dir</span></code>, as demonstrated above. After the initial
download, loading the database again will not trigger a new download. You can specify the database name
using <code class="docutils literal notranslate"><span class="pre">created_db_name</span></code>, or it will use the default name.</p>
<p>After loading the dataset, you can get the training and testing sqls by calling the following methods:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get the testing sqls in PostgreSQL format</span>
<span class="n">ds</span> <span class="o">=</span> <span class="n">StatsTinyDataset</span><span class="p">(</span><span class="n">DatabaseEnum</span><span class="o">.</span><span class="n">PostgreSQL</span><span class="p">)</span>
<span class="n">stats_test_sql_pg</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">read_test_sql</span><span class="p">()</span>
<span class="n">stats_training_sql_pg</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">read_train_sql</span><span class="p">()</span>

<span class="c1"># Get testing sqls in Spark format</span>
<span class="n">ds</span> <span class="o">=</span> <span class="n">StatsTinyDataset</span><span class="p">(</span><span class="n">DatabaseEnum</span><span class="o">.</span><span class="n">SPARK</span><span class="p">)</span>
<span class="n">stats_test_sql_spark</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">read_test_sql</span><span class="p">()</span>
<span class="n">stats_training_sql_spark</span> <span class="o">=</span> <span class="n">ds</span><span class="o">.</span><span class="n">read_train_sql</span><span class="p">()</span>
</pre></div>
</div>
<p>Currently, we support quickly installing the following datasets: <code class="docutils literal notranslate"><span class="pre">ImdbDataset</span></code>,<code class="docutils literal notranslate"><span class="pre">ImdbTinyDataset</span></code>, <code class="docutils literal notranslate"><span class="pre">StatsDataset</span></code>
<code class="docutils literal notranslate"><span class="pre">StatsTinyDataset</span></code>,<code class="docutils literal notranslate"><span class="pre">TpcdsDataset</span></code>.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="system_pipeline.html" class="btn btn-neutral float-left" title="3. System Pipeline" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="example.html" class="btn btn-neutral float-right" title="5. Example" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Alibaba.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>